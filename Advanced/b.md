## float和double类型
### 内存
```
float 32bit
      高位----------->--------------低位
      1bit(符号位)+8bit(指数位)+23bit(尾数位)
      8.25换算成二进制科学计数法
      8(10)=1000(2);
      0.25x2x2=1 0.25(10)=0.01(2);
      8.25(10)=1000.01(2)=1.00001*2^3
  按照上面的存储方式：
      符号位  0，表示为正
      指数位  3+127=130  移位存储方式
      尾数部分 00001= 0000100 0x00 0x00
  因此8.25的存储的为：
      0   1000 0010   0000100 0x00 0x00
  化成32位
      0x41 0x04 0x00 0x00
  放到栈里面去,栈的地址是从高处向低处生长,也就是先将高位放在栈底：
      栈顶
            buffer(1)  0x00
            buffer(2)  0x00
            buffer(3)  0x40
            buffer(4)  0x41
      栈低     
```
* float为8.25的解释程序
```c
#include <stdio.h>
int main ()
{
  //打印float类型的存储情况
  float a=8.25;
  printf("%p %u\n",&a,sizeof(float));
  printf("************************************\n");
  unsigned char *p=(unsigned char *)&a;
  for(int i=0;i<4;i++){
    printf("%p  %x\n",p+i,*(p+i));
  }
  return(0);
}

/*
$ ./test.sh
0061FF24 4
************************************
0061FF24  0
0061FF25  0
0061FF26  4
0061FF27  41
*/
```
***
```
double 64bit
      高位----------->--------------低位
      1bit(符号位)+11bit(指数位)+52bit(尾数位)
      4.5换算成二进制科学计数法
      4(10)=100(2);
      0.5x2=1 0.5(10)=0.1(2);
      4.5(10)=100.1(2)=1.001*2^2
  按照上面的存储方式：
      符号位  0，表示为正
      指数位  2+(2^10-1)  移位存储方式
      尾数部分 001= 0010 0x00 0x00 0x00 0x00 0x00 0x00
  因此4.5的存储的为：
      0   10000000001   0010 0x00 0x00 0x00 0x00 0x00 0x00
  化成32位
      0x40 0x12 0x00 0x00 0x00 0x00 0x00 0x00
  放到栈里面去,栈的地址是从高处向低处生长,也就是先将高位放在栈底：
      栈顶
            buffer(1)  0x00
            buffer(2)  0x00
            buffer(3)  0x00
            buffer(4)  0x00
            buffer(5)  0x00
            buffer(6)  0x00
            buffer(7)  0x12
            buffer(8)  0x40
      栈低     
```
* double为4.5的解释程序
```c
#include <stdio.h>
int main ()
{
  //打印double类型的存储情况
  double b=4.5;
  printf("%p %u\n",&b,sizeof(double));
  printf("************************************\n");
  unsigned char *p=(unsigned char *)&b;
  for(int i=0;i<8;i++){
    printf("%p  %x\n",p+i,*(p+i));
  }
  return(0);
}
/*
$ ./test.sh
0061FF20 8
************************************
0061FF20  0
0061FF21  0
0061FF22  0
0061FF23  0
0061FF24  0
0061FF25  0
0061FF26  12
0061FF27  40
*/
```
***
### 问题
* 为什么以%d格式打印float类型数据的时候大部分为0?
```
在参数传递的时候，C语言统一将float转换为double类型的。
float=7.5的存储：
                 0061FF18  0
                 0061FF19  0
                 0061FF1A  f0
                 0061FF1B  40
double=7.5的储存：
                  0061FF18  0
                  0061FF19  0
                  0061FF1A  0
                  0061FF1B  0
                  0061FF1C  0
                  0061FF1D  0
                  0061FF1E  1e
                  0061FF1F  40
由于低位离栈顶近，将低位的4byte出栈,故为0        
```
###
* 原码：最高位表示符号位
```
有符号的整数，最高位当做符号位，其余符号位表示数值，有问题？
加法： 0000 0001
    +  0000 0001
       0000 0010=2
1-1=?,计算机不认识减法，只认识加法：
      0000 0001
  +   1000 0001
      1000 0010=-2
显然不对，反码上场
```
* 反码：正数的反码和原码相同，负数的反码是符号位不变，其他位取反
```
1+(-1)=?
    0000 0001
  +  1111 1110
    1111  1111
  转化为原码1000  0000=-0
虽然反码解决了相减的问题，但是既然0000 0000表示0，那么就没有-0的必要了，接着出现补码
```
* 补码：正数是本身，负数是反码加1
```
1+(-1)=?
     0000 0001
  +  1111 1111
    10000 0000
这里变成了9位，由于char为8位，最高位1舍弃,运算正确
再看：
-0 原码1000 0000 反码1111 1111 补码0000 0000
+0 原码0000 0000 反码0000 0000 补码0000 0000     
```