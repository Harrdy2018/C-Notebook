### short and unsigned short
* 数值以补码的形式的存储在计算机中，以原码的形式显示给我们
* 正数：补码等于原码
* 负数：补码等于原码取反加1(符号位不变)
```c
// 0111 1111 1111 1111=pow(2,15)-1=32767 二进制原码最大值
// 1111 1111 1111 1111=pow(2,15)-1=-32767 二进制原码最小值
int main(int argc, char *argv[])
{
	short num = 32767;
	short a = 32768;
	short b = 32769;
	printf("%hd\n", num);//32767
	printf("%hd\n", a);//-32768
	printf("%hd\n", b);//-32767
	return 0;
}
```
* 为什么 short b = 32769？ 输出 -32767
```
32769=1000 0000 0000 0001 赋值给 short b 相当于以补码的形式赋值给 b
b的原码=1000 0000 0000 0000(取反)=1111 1111 1111 1111=-32767
```
* 为什么 short a = 32768？ 输出 -32768
```
16为二进制可以表示pow(2,16)个编码方式；
补码+0=0000 0000 0000 0000 原码 0000 0000 0000 0000
补码-0=1000 0000 0000 0000 原码 0111 1111 1111 1111(取反) = 0000 0000 0000 0000 0000
补码会比原码多一个编码出来，这个就是 1000 0000 0000 0000 人为规定这个补码编码为 -32768

32768=1000 0000 0000 0000 赋值给 short b 相当于以补码的形式赋值给 b
```
