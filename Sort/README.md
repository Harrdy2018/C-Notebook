## 排序
* 冒泡排序
```
冒泡排序时间复杂度分析：
如果要排序的表本身是有序的，那么我们比较次数，n-1次比较，时间复杂度o[n];
最坏的情况，逆序，此时需要比较1+2+3+4+...+(n-1)=n(n-1)/2次,时间复杂度o[n^2]
```
* 选择排序算法
```
n个数通过n-1次的比较;从后面记录中选择最小再和前面的交换；
1 9 10 5 8 3 7 4 6 2
1 2 10 5 8 3 7 4 6 9
1 2 3 5 8 10 7 4 6 9
1 2 3 4 8 10 7 5 6 9
1 2 3 4 5 10 7 8 6 9
1 2 3 4 5 6 7 8 10 9
1 2 3 4 5 6 7 8 10 9
1 2 3 4 5 6 7 8 10 9
1 2 3 4 5 6 7 8 9 10
选择排序时间复杂度分析：交换移动数据次数相当少
无论最好最差情况，其比较次数一样多，需要比较n-1+n-2+...+1=n(n-1)/2；
对于交换次数而言，当最好的时候，为0,最差的时候，交换次数n-1次，最终排序时间为比较与交换的总和，时间复杂度为o[n^2]；
排序性能上略优于冒泡排序；
```
* 堆排序
```
先构造一个大顶堆，或者小顶堆；
loop
  交换两端元素；
  继续构建堆
```