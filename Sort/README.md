## 排序
* 冒泡排序
```
冒泡排序时间复杂度分析：
如果要排序的表本身是有序的，那么我们比较次数，n-1次比较，时间复杂度o[n];
最坏的情况，逆序，此时需要比较1+2+3+4+...+(n-1)=n(n-1)/2次,时间复杂度o[n^2]
```
* 选择排序算法
```
n个数通过n-1次的比较;从后面记录中选择最小再和前面的交换；
1 9 10 5 8 3 7 4 6 2
1 2 10 5 8 3 7 4 6 9
1 2 3 5 8 10 7 4 6 9
1 2 3 4 8 10 7 5 6 9
1 2 3 4 5 10 7 8 6 9
1 2 3 4 5 6 7 8 10 9
1 2 3 4 5 6 7 8 10 9
1 2 3 4 5 6 7 8 10 9
1 2 3 4 5 6 7 8 9 10
选择排序时间复杂度分析：交换移动数据次数相当少
无论最好最差情况，其比较次数一样多，需要比较n-1+n-2+...+1=n(n-1)/2；
对于交换次数而言，当最好的时候，为0,最差的时候，交换次数n-1次，最终排序时间为比较与交换的总和，时间复杂度为o[n^2]；
排序性能上略优于冒泡排序；
```
* 直接插入排序算法
```c
typedef struct {
  int r[MAXSIZE+1];//用于储存排序数组，r[0]用作哨兵或临时变量
  int length;//有多少个数需要排序
} SqList;
  //这个算法和玩扑克牌一样，对[0,5,3,4,6,2]进行排序
  //我以5为标准，只需看后面的3
  for(int i=2;i<=L->length;i++){
    if(L->r[i]<L->r[i-1]){
      //如果后面的比前面小，则将此时的数放在哨兵位置
      L->r[0]=L->r[i];
      int j;
      //循环r[i]前面的数，依次与哨兵比较，如果哨兵更小，则将大的数后移
      //此时的j记录的是大数后移之前的位置，j--，继续找，继续移,
      //如果没找到，将哨兵放在r[j+1]的位置即可
      for(j=i-1;L->r[0]<L->r[j];j--){
        L->r[j+1]=L->r[j];
      }
      L->r[j+1]=L->r[0];
    }
  }
```
***
```直接插入排序算法复杂度分析
空间复杂度：需要一个记录的辅助空间；
因此关注于时间复杂度：
最好的情况，拿到手就是[0,2,3,4,5,6],只需要比较n-1次即可，没有移动记录，时间复杂度o[n]；
最坏的情况，逆序[0,6,5,4,3,2],需要比较2+3+...+n=(n+2)(n-1)/2
            为什么第一个为2?
                5先和6比较,然后5作为哨兵,哨兵再和6比较
           需要移动：3+4+5+...+(n+1)=(n+4)(n-1)/2
            为什么第一个为3?
                5先移动到哨兵的位置，6再移动到5的位置，哨兵再移动一次
根据概率相同的原则：若待排序对象序列中出现各种可能排列的概率相同，则可取最好情况和最坏情况的平均情况。
则平均比较和平均移动次数约为n^2/4,直接排序算法的时间复杂度为o[n^2];
```   
***       
* 堆排序
```
先构造一个大顶堆，或者小顶堆；
loop
  交换两端元素；
  继续构建堆
```