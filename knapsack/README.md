## 背包算法
### 0-1背包
```
商品个数N=5
五件物品重量：weight=[4,5,6,2,2];为了方便weight=[0,4,5,6,2,2]
五件物品价值：value=[6,4,5,3,6];为了方便value=[0,6,4,5,3,6]
背包容量C=10
求当前状态下的最优二维价值数组即可，maxValue[N+1][C+1];
价值矩阵先初始化：
当row=0时，什么也装不了，也没价值，maxValue[0][col]=0;
当col=0时,虽然商品有价值，但是奈何背包容量是0，也是什么也装不了，maxValue[row][0]=0;
value    weight  C={0  1   2   3   4   5   6   7   8   9   10}
  0       0        0   0   0   0   0   0   0   0   0   0   0
  6       4        0   0   0   0   0   0   0   0   0   0   0
  4       5        0   0   0   0   0   0   0   0   0   0   0
  5       6        0   0   0   0   0   0   0   0   0   0   0
  3       2        0   0   0   0   0   0   0   0   0   0   0
  6       2        0   0   0   0   0   0   0   0   0   0   0
求矩阵：
从每一列开始，从上到下背包依次装商品，选择最大的价值的装；
当C=1时：
    weight[1]>C,不能装。
    当我走到第二行的时候，表示背包C的容量尝试装weight[1]和weight[2],发现没有一个可装的。
    一直走到最后，背包什么也装不了。
当C=2时：
    因为只有weight[4]=2=C,此时maxValue[4][2]=3;
    走到第5行的时候，发现weight[5]也可以装下，为了达到最大，我舍弃weight[4],则maxValue[5][2]=6
那么maxValue[5][8]=15?
    现在maxValue[5][8]=?,需要求？
    weight[5]=6<C，表示当前背包的容量C=8可以单独的装下weight[5];
    既然可以装下，则可以分解为两个子问题，一是我不装这个物品求其背包的总价值即maxValue[5-1][8]=9；
    二是，那好吧，我装着试一试，maxValue[5-1][8-weight[5]]+value[5]=9+6=15；
    取两个子问题的最大值即可。
递推公式：
if row=0 or col=0
    maxValue[row][col]=0                                     
if weight[row]>col
    //既然你单独都装不进来，那好，不要你了
    maxValue[row][col]=maxValue[row-1][col]    
if weight[row]<=col              
    //你单独一个可以装进来，那好，尝试一下吧
    //我不装你试试，可能价值大呢      
    int a=maxValue[row-1][col]                             
    //算了，我还是试着装下你吧，万一呢？
    int b=maxValue[row-1][col-weight[row]]+value[row]
    //你们两比比吧，我取最大的
    maxValue[row][col]=Max{a,b};
value    weight  C={0  1   2   3   4   5   6   7   8   9   10}
  0        0       0   0   0   0   0   0   0   0   0   0   0
  6        4       0   0   0   0   6   6   6   6   6   6   6
  4        5       0   0   0   0   6   6   6   6   6  10  10
  5        6       0   0   0   0   6   6   6   6   6  10  11
  3        2       0   0   3   3   6   6   9   9   9  10  11
  6        2       0   0   6   6   9   9  12  12  15  15  15
```
### 完全背包问题
```
每种商品的数量足够的多。取之不尽。
price={0,2,3,4,7};
want={0,1,3,5,9};
want    price  M={ 0   1   2   3   4   5   6   7   8   9   10}
  0        0       0   0   0   0   0   0   0   0   0   0   0
  1        2       0   0   1   1   2   2   3   3   4   4   5
  3        3       0   0   1   3   3   4   6   6   7   9   9
  5        4       0   0   1   3   5   5   6   8   10  10  11
  9        7       0   0   1   3   5   5   6   9   10  10  12
arr[5][10]=?
由于钱币为10,故可以买下price=7,当且仅当只能买一个，现在有两个选择；
第一、我不买price=7,则为arr[5-1][10]=11;
第二、我买还不行么？arr[5-1][10-7]+9=3+9=12;
那好，我还是买下吧，现在我的收益为12;
arr[1][10]=?
由于钱币为10,故可以买下price=2,当且仅当只能买5个(遵循能买则买的原则)，现在有两个选择；
第一、我不买price=2,则为arr[0][10]=0;
第二、我买还不行么？arr[0][0]+1*5=0+5=5;
那好，我还是买下吧，现在我的收益为5;
```
### 多重背包问题
```
每种商品的数量有限。不是你想取多少就是多少。但是劲量的取就行了。
price={0,1,2,2};
want={0,6,10,20};
nums={0,10,5,2};
nums      want    price  M={0   1   2    3    4    5    6    7    8 }
   0       0        0       0   0   0    0    0    0    0    0    0  
   10      6        1       0   6   12   18   24   30   36   42   48   
   5       10       2       0   6   12   18   24   30   36   42   48   
   2       20       2       0   6   20   26   40   46   52   58   64  
arr[4][8]=?
由于钱币为8,故可以买下price=2,当且仅当只能买二个，现在有两个选择；
第一、我不买price=2,则为arr[4-1][8]=48;
第二、我买还不行么？arr[4-1][8-2*2]+20*2==24+40=64;
那好，我还是买下吧，现在我的收益为64;
arr[1][8]=?
由于钱币为8,故可以买下price=1,当且仅当只能买8个(遵循能买则买的原则)，现在有两个选择；
第一、我不买price=1,则为arr[0][8]=0;
第二、我买还不行么？arr[0][0]+8*6=0+48=48;
那好，我还是买下吧，现在我的收益为48;
```